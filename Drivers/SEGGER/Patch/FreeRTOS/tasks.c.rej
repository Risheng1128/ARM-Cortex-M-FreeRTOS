--- FreeRTOS/tasks.c	2020-12-16 00:24:28.000000000 +0530
+++ new/tasks.c	2021-02-04 18:30:34.406338500 +0530
@@ -221,6 +221,17 @@
     taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                                                \
     vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
     tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
+
+/*
+ * Place the task represented by pxTCB which has been in a ready list before
+ * into the appropriate ready list for the task.
+ * It is inserted at the end of the list.
+ */
+#define prvReaddTaskToReadyList( pxTCB )															\
+	traceREADDED_TASK_TO_READY_STATE( pxTCB );														\
+	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
+	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
+	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 /*-----------------------------------------------------------*/
 
 /*
@@ -1674,7 +1685,7 @@
                         mtCOVERAGE_TEST_MARKER();
                     }
 
-                    prvAddTaskToReadyList( pxTCB );
+					prvReaddTaskToReadyList( pxTCB );
                 }
                 else
                 {
@@ -1735,7 +1746,7 @@
             {
                 mtCOVERAGE_TEST_MARKER();
             }
-
+			traceMOVED_TASK_TO_SUSPENDED_LIST(pxTCB);
             vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 
             #if ( configUSE_TASK_NOTIFICATIONS == 1 )
@@ -3927,6 +3938,20 @@
 #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
 /*-----------------------------------------------------------*/
 
+#if (INCLUDE_pxTaskGetStackStart == 1)
+	uint8_t* pxTaskGetStackStart( TaskHandle_t xTask)
+	{
+	    TCB_t *pxTCB;
+	    UBaseType_t uxReturn;
+        (void)uxReturn;
+
+		pxTCB = prvGetTCBFromHandle( xTask );
+		return ( uint8_t * ) pxTCB->pxStack;
+	}
+
+#endif /* INCLUDE_pxTaskGetStackStart */
+/*-----------------------------------------------------------*/
+
 #if ( INCLUDE_vTaskDelete == 1 )
 
     static void prvDeleteTCB( TCB_t * pxTCB )
@@ -4098,7 +4123,7 @@
 
                     /* Inherit the priority before being moved into the new list. */
                     pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
-                    prvAddTaskToReadyList( pxMutexHolderTCB );
+                    prvReaddTaskToReadyList( pxMutexHolderTCB );
                 }
                 else
                 {
@@ -4188,7 +4213,7 @@
                      * any other purpose if this task is running, and it must be
                      * running to give back the mutex. */
                     listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-                    prvAddTaskToReadyList( pxTCB );
+                    prvReaddTaskToReadyList( pxTCB );
 
                     /* Return true to indicate that a context switch is required.
                      * This is only actually required in the corner case whereby
@@ -4722,7 +4747,7 @@
 
         taskENTER_CRITICAL();
         {
-            traceTASK_NOTIFY_TAKE( uxIndexToWait );
+            traceTASK_NOTIFY_TAKE(  );
             ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 
             if( ulReturn != 0UL )
@@ -4801,7 +4826,7 @@
 
         taskENTER_CRITICAL();
         {
-            traceTASK_NOTIFY_WAIT( uxIndexToWait );
+            traceTASK_NOTIFY_WAIT(  );
 
             if( pulNotificationValue != NULL )
             {
@@ -4908,7 +4933,7 @@
                     break;
             }
 
-            traceTASK_NOTIFY( uxIndexToNotify );
+            traceTASK_NOTIFY(  );
 
             /* If the task is in the blocked state specifically to wait for a
              * notification then unblock it now. */
@@ -5050,7 +5075,7 @@
                     break;
             }
 
-            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );
+            traceTASK_NOTIFY_FROM_ISR(  );
 
             /* If the task is in the blocked state specifically to wait for a
              * notification then unblock it now. */
@@ -5141,7 +5166,7 @@
              * semaphore. */
             ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 
-            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );
+            traceTASK_NOTIFY_GIVE_FROM_ISR(  );
 
             /* If the task is in the blocked state specifically to wait for a
              * notification then unblock it now. */
@@ -5295,6 +5320,7 @@
                 /* Add the task to the suspended task list instead of a delayed task
                  * list to ensure it is not woken by a timing event.  It will block
                  * indefinitely. */
+				traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
                 vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
             }
             else
@@ -5311,12 +5337,14 @@
                 {
                     /* Wake time has overflowed.  Place this item in the overflow
                      * list. */
+					traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
                     vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
                 }
                 else
                 {
                     /* The wake time has not overflowed, so the current block list
                      * is used. */
+					traceMOVED_TASK_TO_DELAYED_LIST();
                     vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 
                     /* If the task entering the blocked state was placed at the
@@ -5346,11 +5374,13 @@
             if( xTimeToWake < xConstTickCount )
             {
                 /* Wake time has overflowed.  Place this item in the overflow list. */
+				traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
                 vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
             }
             else
             {
                 /* The wake time has not overflowed, so the current block list is used. */
+				traceMOVED_TASK_TO_DELAYED_LIST();
                 vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 
                 /* If the task entering the blocked state was placed at the head of the
